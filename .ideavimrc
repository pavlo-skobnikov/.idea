" -> https://github.com/JetBrains/ideavim/wiki


"" Basic configurations.
" -> https://raw.githubusercontent.com/wiki/JetBrains/ideavim/set-commands.md

" Set space key as the global leader.
" NOTE: Should be set early on in the configuration.
let mapleader = " "

" Never timeout when waiting for the next key of a keymap.
set notimeout

" Remember command-line history.
set history=50

" Match w/ `%`.
set matchpairs

" Show line numbers.
set number

" Show line numbers relative to the current line.
set relativenumber

" Ignore case in search patterns.
set ignorecase

" Use case sensitive search if any character in the pattern is uppercase.
set smartcase

" Wrap around the buffer when searching.
set wrapscan

" Use the system's clipboard as the main one.
set clipboard+=unnamed

" Show Current Vim Mode.
set showmode

" Search as characters are entered.
set incsearch

" Highlight search results.
set hlsearch

" Use the IntelliJ's "smart join" feature for `J` motion.
set ideajoin=true

" Switch to the visual mode after selecting a refactor action.
set idearefactormode=keep


"" Plugins and plugin-specific configurations.

" [count]/{Visual} + REGISTER + gr = Replace from register.
Plug 'vim-scripts/ReplaceWithRegister'

" Exchange text objects with `cx...`.
Plug 'tommcdo/vim-exchange'

" Add the entire buffer text object: a-/ie (around/inside the (entire) buffer contents).
Plug 'kana/vim-textobj-entire'

" Improvements to `{` and `}` motions to include blank lines as well.
Plug 'dbakker/vim-paragraph-motion'

" Adds and indentation level object: a-/ii (around/inside indentation level).
Plug 'michaeljsmith/vim-indent-object'

" Text objects for arguments and parameters.
Plug 'vim-scripts/argtextobj.vim'

" Handle more arguments than just simple parentheses.
let g:argtextobj_pairs = '(:),{:},[:],<:>'

" Highlight yanked text w/o having to use visual mode.
Plug 'machakann/vim-highlightedyank'

" GOTO commenting.
Plug 'tpope/vim-commentary'

" Surround text objects w/ paired characters.
Plug 'tpope/vim-surround'

" Navigate file tree w/ vim keys.
Plug 'preservim/nerdtree'

" Show the actions of a keymap.
set which-key

" Show the actions pop-up after 200ms.
let g:WhichKey_DefaultDelay = 100

" Show the default vim actions implemented by IdeaVim.
let g:WhichKey_ShowVimActions = 'true'


"" Basic custom mappings.

" Remove highlights on Escape.
nnoremap <Esc> :<C-u>nohl<CR><Esc>

" Easy window navigation
nnoremap <C-h> <C-w>h
nnoremap <C-j> <C-w>j
nnoremap <C-k> <C-w>k
nnoremap <C-l> <C-w>l

" Center screen on page movement.
nnoremap <C-d> <C-d>zz
nnoremap <C-u> <C-u>zz

" Open project tree w/ focus on the currently opened file.
nmap - <Action>(SelectInProjectView)

" Increase/decrease selection.
vmap ; <Action>(EditorSelectWord)
vmap , <Action>(EditorUnSelectWord)

" Replace multiple successive whitespaces with a single space.
nnoremap d<SPACE> f<SPACE>diwi<SPACE><ESC>
let g:WhichKeyDesc_DeleteExtraSpaces = 'd<Space> delete-extra-spaces'

nnoremap c<SPACE> f<SPACE>diwi<SPACE>
let g:WhichKeyDesc_ChangeExtraSpaces = 'c<Space> change-extra-spaces'

" Add a new line above/below the current line.
nnoremap [<Space> mzO<Esc>`z
vnoremap [<Space> <Esc>O<Esc>gv
let g:WhichKeyDesc_AddLineAbove = '[<Space> add-line-above'

nnoremap ]<Space> mzo<Esc>`z
vnoremap [<Space> <Esc>O<Esc>gv
let g:WhichKeyDesc_AddLineBelow = ']<Space> add-line-below'

" Toggle fold.
nmap za <Action>(ExpandCollapseToggleAction)
let g:WhichKeyDesc_ExpandCollapseToggleAction = 'za toggle-fold'

" Insert system clipboard register.
inoremap <C-i> <C-r>*

" Paste w/o replacing the system clipboard register.
vnoremap <Leader>P "_dP

" Delete w/o replacing the system clipboard register.
vnoremap <Leader>D "_d


"" [ and ] pair mappings.

" Easily navigate between searched items.
nmap [q <Action>(PreviousOccurence)
let g:WhichKeyDesc_PreviousOccurence = '[q previous-qflist'

nmap ]q <Action>(NextOccurence)
let g:WhichKeyDesc_NextOccurence = ']q next-qflist'

" Jump between hunks.
nmap [c <Action>(VcsShowPrevChangeMarker)
let g:WhichKeyDesc_VcsShowPrevChangeMarker = '[c previous-change'

nmap ]c <Action>(VcsShowNextChangeMarker)
let g:WhichKeyDesc_VcsShowNextChangeMarker = ']c next-change'

" Jump between diagnostics.
nmap [d <Action>(GotoPreviousError)
let g:WhichKeyDesc_GotoPreviousError = '[d previous-diagnostic'

nmap ]d <Action>(GotoNextError)
let g:WhichKeyDesc_GotoNextError = ']d next-diagnostic'

" Jump between functions.
nmap [f <Action>(MethodUp)
let g:WhichKeyDesc_MethodUp = '[f previous-function'

nmap ]f <Action>(MethodDown)
let g:WhichKeyDesc_MethodDown = ']f next-function'


"" LSP mappings.

" Quick documentation peek.
nmap K <Action>QuickJavaDoc
vmap K <Action>QuickJavaDoc

" Resolve type information of the expression.
nmap T <Action>ExpressionTypeInfo
vmap T <Action>ExpressionTypeInfo

" Show parameter information.
nmap <C-S-k> <Action>ParameterInfo
vmap <C-S-k> <Action>ParameterInfo
imap <C-S-k> <Action>ParameterInfo

" Quick GOTOs.
nmap gd <Action>(GotoDeclaration)
let g:WhichKeyDesc_GotoLeader_GotoDeclaration = 'gd definition'

nmap gD <Action>(GotoTypeDeclaration)
let g:WhichKeyDesc_GotoLeader_GotoTypeDeclaration = 'gD type-declaration'

nmap gR <Action>(ShowUsages)
let g:WhichKeyDesc_GotoLeader_ShowUsages = 'gR references'

nmap gI <Action>(GotoImplementation)
let g:WhichKeyDesc_GotoLeader_GotoImplementation = 'gI implementation'

nmap gS <Action>(GotoSuperMethod)
let g:WhichKeyDesc_GotoLeader_GotoSuperMethod = 'gS super'

" +lsp
let g:WhichKeyDesc_GotoLspActionsLeader = 'gl +[l]sp'

nmap glr <Action>(Refactorings.QuickListPopupAction)
let g:WhichKeyDesc_GotoLspActionsLeader_Refactorings.QuickListPopupAction = 'glr refactor-action'

nmap gla <Action>(ShowIntentionActions)
let g:WhichKeyDesc_GotoLspActionsLeader_ShowIntentionActions = 'gla contextual-actions'

nmap gln <Action>(RenameElement)
let g:WhichKeyDesc_GotoLspActionsLeader_RenameElement = 'gln rename'

nmap glh <Action>(HighlightUsagesInFile)
let g:WhichKeyDesc_GotoLspActionsLeader_HighlightUsagesInFile = 'glh highlight-symbol'

nmap glf <Action>(ShowErrorDescription)
let g:WhichKeyDesc_GotoLspActionsLeader_ShowErrorDescription = 'glf float-diagnostics'

nmap glo <Action>(OptimizeImports)
let g:WhichKeyDesc_GotoLspActionsLeader_OptimizeImports = 'glo optimize-imports'

nmap gli <Action>(InspectCode)
let g:WhichKeyDesc_GotoLspActionsLeader_InspectCode = 'gli inspect-code'


" +symbols
let g:WhichKeyDesc_GotoLspSymbolsLeader = 'gs +[s]earch'

nmap gsr <Action>(FindUsages)
let g:WhichKeyDesc_GotoLspSymbolsLeader_FindUsages = 'gsr references-to-qflist'

nmap gsd <Action>(FileStructurePopup)
let g:WhichKeyDesc_GotoLspSymbolsLeader_FileStructurePopup = 'gsd document-symbols'

nmap gsw <Action>(GotoSymbol)
let g:WhichKeyDesc_GotoLspSymbolsLeader_GotoSymbol = 'gsw workspace-symbols'

nmap gsc <Action>(GotoClass)
let g:WhichKeyDesc_GotoLspSymbolsLeader_GotoClass = 'gsc class-symbols'

nmap gse <Action>(ActivateProblemsViewToolWindow)
let g:WhichKeyDesc_GotoLspSymbolsLeader_ActivateProblemsViewToolWindow = 'gse errors'

nmap gsq <Action>(ActivateFindToolWindow)
let g:WhichKeyDesc_GotoLspSymbolsLeader_ActivateFindToolWindow = 'gsq qflist'

nmap gsh <Action>(HierarchyGroup)
let g:WhichKeyDesc_GotoLspSymbolsLeader_HierarchyGroup = 'gsh hierarchies'


"" Leader mappings.
" +leader

map <Leader><Leader> <Action>(SearchEverywhere)
let g:WhichKeyDesc_SearchEverywhere = '<leader><leader> search-everything'

map <Leader>: <Action>(GotoAction)
let g:WhichKeyDesc_GotoAction = '<leader>: search-actions'

map <Leader>/ <Action>(FindInPath)
let g:WhichKeyDesc_FindInPath = '<leader>/ grep-files'

map <Leader>= <Action>(ReformatCode)
let g:WhichKeyDesc_ReformatCode = '<leader>= reformat-code'

map <Leader>~ <Action>(JumpToLastWindow)
let g:WhichKeyDesc_JumpToLastWindow = '<leader>~ show-last-popup'


"
" +application

let g:WhichKeyDesc_ApplicationLeader = '<leader>a +[a]pplication'

map <Leader>ae <Action>(ActivateEventLogToolWindow)
let g:WhichKeyDesc_ApplicationLeader_ActivateEventLogToolWindow = '<leader>ae show-event-log'

map <Leader>ar <Action>(IdeaVim.ReloadVimRc.reload)
let g:WhichKeyDesc_ApplicationLeader_IdeaVim_ReloadVimRc_reload = '<leader>ar reload-ideavim-config'

map <Leader>at <Action>(ChangeLaf)
let g:WhichKeyDesc_ApplicationLeader_ChangeLaf = '<leader>at change-theme'

map <Leader>aa <Action>(VimFindActionIdAction)
let g:WhichKeyDesc_ApplicationLeader_VimFindActionIdAction = '<leader>aa toggle-action-id-tracking'


"
" +buffers

let g:WhichKeyDesc_BuffersLeader = '<leader>b +[b]uffers'

map <Leader>bb <Action>(Switcher)
let g:WhichKeyDesc_BuffersLeader_Switcher = '<leader>bb switch-buffers'

" +buffer-delete
let g:WhichKeyDesc_BuffersDeleteLeader = '<leader>bd +[d]elete'

map <Leader>bdc <Action>(CloseContent)
let g:WhichKeyDesc_BuffersDeleteLeader_CloseContent = '<leader>bd delete-current-buffer'

map <Leader>bda <Action>(CloseAllEditors)
let g:WhichKeyDesc_BuffersDeleteLeader_CloseAllEditors = '<leader>bD delete-all-buffers'

map <Leader>bdo <Action>(CloseAllEditorsButActive)
let g:WhichKeyDesc_BuffersDeleteLeader_CloseAllEditorsButActive = '<leader>bo delete-other-buffers'

" +buffer-scratch
let g:WhichKeyDesc_BuffersScratchLeader = '<leader>bs +[s]cratch'

map <Leader>bf <Action>(NewScratchFile)
let g:WhichKeyDesc_BuffersScratchLeader_NewScratchFile = '<leader>bf scratch-file'

map <Leader>bb <Action>(NewScratchBuffer)
let g:WhichKeyDesc_BuffersScratchLeader_NewScratchBuffer = '<leader>bb scratch-buffer'


"
" +code

let g:WhichKeyDesc_CodeLeader = '<leader>c +[c]ode'

map <Leader>cc <Action>(CompileDirty)
let g:WhichKeyDesc_CodeLeader_CompileDirty = '<leader>cc compile-dirty'

map <Leader>cC <Action>(Compile)
let g:WhichKeyDesc_CodeLeader_Compile = '<leader>cC recompile'

map <Leader>cb <Action>(ActivateBuildToolWindow)
let g:WhichKeyDesc_CodeLeader_ActivateBuildToolWindow = '<leader>cb build'

map <Leader>cM <Action>(MakeModule)
let g:WhichKeyDesc_CodeLeader_MakeModule = '<leader>cc compile-current-module'

map <Leader>cp <Action>(ActivatePackageSearchToolWindow)
let g:WhichKeyDesc_CodeLeader_ActivatePackageSearchToolWindow = '<leader>cp packages'

map <Leader>cr <Action>(CompileProject)
let g:WhichKeyDesc_CodeLeader_CompileProject = '<leader>cr rebuild-project'

" +gradle
let g:WhichKeyDesc_CodeGradleLeader = '<leader>cg +[g]radle'

map <Leader>cge <Action>(Gradle.ExecuteTask)
let g:WhichKeyDesc_CodeGradleLeader_Gradle_ExecuteTask = '<leader>cge execute-task'

map <Leader>cgg <Action>(ActivateGradleToolWindow)
let g:WhichKeyDesc_CodeGradleLeader_ActivateGradleToolWindow = '<leader>cgg gradle-tool-window'

map <Leader>cgr <Action>(ExternalSystem_RefreshAllProjects)
let g:WhichKeyDesc_CodeGradleLeader_ExternalSystem_RefreshAllProjects = '<leader>cgr reload-all-projects'

" +maven
let g:WhichKeyDesc_CodeMavenLeader = '<leader>cm +[m]aven'

map <Leader>cme <Action>(Maven.ExecuteGoal)
let g:WhichKeyDesc_CodeMavenLeader_Maven_ExecuteGoal = '<leader>cme execute-goal'

map <Leader>cmm <Action>(ActivateMavenToolWindow)
let g:WhichKeyDesc_CodeMavenLeader_ActivateMavenToolWindow = '<leader>cmm maven-tool-window'

map <Leader>cmr <Action>(Maven.Reimport)
let g:WhichKeyDesc_CodeMavenLeader_Maven_Reimport = '<leader>cmr reload-all-projects'


"
" +debug

let g:WhichKeyDesc_DebugLeader = '<leader>d +[d]ebug'

map <Leader>c <Action>(Debugger.RemoveAllBreakpointsInFile)
let g:WhichKeyDesc_DebugLeader_Debugger_RemoveAllBreakpointsInFile = '<leader>c clear-all-breakpoints'

map <Leader>d <Action>(ActivateDebugToolWindow)
let g:WhichKeyDesc_DebugLeader_ActivateDebugToolWindow = '<leader>d debug-tool-window'

map <Leader>o <Action>(KotlinConsoleREPL)
let g:WhichKeyDesc_DebugLeader_KotlinConsoleREPL = '<leader>o open-kotlin-repl'

" +breakpoints
let g:WhichKeyDesc_DebugBreakpointToggleLeader = '<leader>db +[b]reakpoint-toggle'

map <Leader>dba <Action>(ToggleBreakpointAction)
let g:WhichKeyDesc_DebugBreakpointToggleLeader_ToggleBreakpointAction = '<leader>dba action'

map <Leader>dbb <Action>(ToggleLineBreakpoint)
let g:WhichKeyDesc_DebugBreakpointToggleLeader_ToggleLineBreakpoint = '<leader>dbb plain'

map <Leader>dbe <Action>(ToggleBreakpointEnabled)
let g:WhichKeyDesc_DebugBreakpointToggleLeader_ToggleBreakpointEnabled = '<leader>dbe enabled'

map <Leader>dbf <Action>(ToggleFieldBreakpoint)
let g:WhichKeyDesc_DebugBreakpointToggleLeader_ToggleFieldBreakpoint = '<leader>dbf field'

map <Leader>dbm <Action>(ToggleMethodBreakpoint)
let g:WhichKeyDesc_DebugBreakpointToggleLeader_ToggleMethodBreakpoint = '<leader>dbm method'

map <Leader>dbv <Action>(ViewBreakpoints)
let g:WhichKeyDesc_DebugBreakpointToggleLeader_ViewBreakpoints = '<leader>dbv view-all'

" +run
let g:WhichKeyDesc_DebugRunLeader = '<leader>dr +[r]un'

map <Leader>drc <Action>(DebugClass)
let g:WhichKeyDesc_DebugRunLeader_DebugClass = '<leader>drc debug-class'

map <Leader>drd <Action>(Debug)
let g:WhichKeyDesc_DebugRunLeader_Debug = '<leader>drd run-debug'

map <Leader>drf <Action>(ChooseDebugConfiguration)
let g:WhichKeyDesc_DebugRunLeader_ChooseDebugConfiguration = '<leader>drf find-debug-config'

map <Leader>drr <Action>(Resume)
let g:WhichKeyDesc_DebugRunLeader_Resume = '<leader>drr resume-debug'

" +step
let g:WhichKeyDesc_DebugStepLeader = '<leader>ds +[s]tep'

map <leader>dsc <Action>(RunToCursor)
let g:WhichKeyDesc_DebugStepLeader_RunToCursor = '<leader>dsc to-cursor'

map <leader>dsi <Action>(StepInto)
let g:WhichKeyDesc_DebugStepLeader_StepInto = '<leader>dsi into'

map <leader>dsn <Action>(StepOver)
let g:WhichKeyDesc_DebugStepLeader_StepOver = '<leader>dsn over'

map <leader>dso <Action>(StepOut)
let g:WhichKeyDesc_DebugStepLeader_StepOut = '<leader>dso out'


"
" +files

let g:WhichKeyDesc_FilesLeader = '<leader>f +[f]iles'

map <Leader>ff <Action>(GotoFile)
let g:WhichKeyDesc_FilesLeader_GotoFile = '<leader>ff find-file'

map <Leader>fr <Action>(RecentFiles)
let g:WhichKeyDesc_FilesLeader_RecentFiles = '<leader>fr recent-files'

map <Leader>fa <Action>(RefactoringMenu)
let g:WhichKeyDesc_FilesLeader_RefactoringMenu = '<leader>fa file-actions'

map <Leader>fy <Action>(CopyAbsolutePath)
let g:WhichKeyDesc_FilesLeader_CopyAbsolutePath = '<leader>fy copy-fname'


"
" +git

let g:WhichKeyDesc_GitLeader = '<leader>g +[g]it'

map <Leader>gg <Action>(Git.Commit.Stage)
let g:WhichKeyDesc_GitLeader_Git_Commit_Stage = '<leader>gg git-ui'

map <Leader>g. <Action>(Git.FileActions)
let g:WhichKeyDesc_GitLeader_Git_FileActions = '<leader>g. git-file-actions'

map <Leader>g' <Action>(GitHub.MainMenu)
let g:WhichKeyDesc_GitLeader_GitHub_MainMenu = "<leader>g' github-menu"

map <Leader>g/ <Action>(Git.Menu)
let g:WhichKeyDesc_GitLeader_Git_Menu = '<leader>g/ git-menu'

map <Leader>gh <Action>(Vcs.ShowTabbedFileHistory)
let g:WhichKeyDesc_GitLeader_Vcs_ShowTabbedFileHistory = '<leader>gh file-commit-history'

map <Leader>gb <Action>(Annotate)
let g:WhichKeyDesc_GitLeader_Annotate = '<leader>gb blame'

" +create
let g:WhichKeyDesc_GitCreateLeader = '<leader>gc +[c]reate'

map <Leader>gcb <Action>(Git.CreateNewBranch)
let g:WhichKeyDesc_GitCreateLeader_Git_CreateNewBranch = '<leader>gcb branch'

map <Leader>gcp <Action>(Github.Create.Pull.Request)
let g:WhichKeyDesc_GitCreateLeader_Github_Create_Pull_Request = '<leader>gcp pull-request'

map <Leader>gcr <Action>(Git.Init)
let g:WhichKeyDesc_GitCreateLeader_Git_Init = '<leader>gcr initialize-repo'

map <Leader>gcR <Action>(Vcs.VcsClone)
let g:WhichKeyDesc_GitCreateLeader_Vcs_VcsClone = '<leader>gcR clone-repo'

" +list
let g:WhichKeyDesc_GitListLeader = '<leader>gl +[l]ist'

map <Leader>glp <Action>(Github.View.Pull.Request)
let g:WhichKeyDesc_GitListLeader_Github_View_Pull_Request = '<leader>glp pull-requests'

map <Leader>glb <Action>(Git.Branches)
let g:WhichKeyDesc_GitListLeader_Git_Branches = '<leader>glb branches'

" +remote
let g:WhichKeyDesc_GitRemoteLeader = '<leader>gr +[r]emote'

map <Leader>grf <Action>(Git.Fetch)
let g:WhichKeyDesc_GitRemoteLeader_Git_Fetch = '<leader>grf fetch'

map <Leader>grl <Action>(Vcs.UpdateProject)
let g:WhichKeyDesc_GitRemoteLeader_Vcs_UpdateProject = '<leader>grl pull'

map <Leader>grs <Action>(Vcs.Push)
let g:WhichKeyDesc_GitRemoteLeader_Vcs_Push = '<leader>grs push'

" +open
let g:WhichKeyDesc_GitOpenLeader = '<leader>go +[o]pen'

map <Leader>goo <Action>(Github.Open.In.Browser)
let g:WhichKeyDesc_GitOpenLeader_Github_Open_In_Browser = '<leader>goo region-in-browser'

map <Leader>gop <Action>(com.github.shiraji.findpullrequest.action.FindPullRequestAction)
let g:WhichKeyDesc_GitOpenLeader_com_github_shiraji_findpullrequest_action_FindPullRequestAction = '<leader>gop pull-request'

" +show
let g:WhichKeyDesc_GitShowLeader = '<leader>gs +[s]how'

map <Leader>gsl <Action>(Vcs.Show.Log)
let g:WhichKeyDesc_GitShowLeader_Vcs_Show_Log = '<leader>gsl log'

map <Leader>gsh <Action>(Vcs.Show.Shelf)
let g:WhichKeyDesc_GitShowLeader_Vcs_Show_Shelf = '<leader>gsh shelf'


"
" +hunks

let g:WhichKeyDesc_HunksLeader = '<leader>h +[h]unks'

" +hunks-stage
let g:WhichKeyDesc_HunksStageLeader = '<leader>hs +[s]tage'

map <Leader>hsb <Action>(Git.Add)
let g:WhichKeyDesc_HunksStageLeader_Git_Add = '<leader>hsb buffer'

" +hunks-reset
let g:WhichKeyDesc_HunksResetLeader = '<leader>hr +[r]eset'

map <Leader>hrr <Action>(Vcs.RollbackChangedLines)
let g:WhichKeyDesc_HunksResetLeader_Vcs_RollbackChangedLines = '<leader>hrr hunk'


"
" +bookmarks

let g:WhichKeyDesc_BookmarksLeader = '<leader>m +book[m]arks'

map <Leader>mm <Action>(Bookmarks)
let g:WhichKeyDesc_BookmarksLeader_Bookmarks = '<leader>mm bookmark-menu'

map <Leader>mf <Action>(ShowBookmarks)
let g:WhichKeyDesc_BookmarksLeader_ShowBookmarks = '<leader>mf find-bookmark'


"
" +open

let g:WhichKeyDesc_OpenLeader = '<leader>o +[o]pen'

nmap <Leader>ow <Action>(EditSourceInNewWindow)
let g:WhichKeyDesc_OpenLeader_EditSourceInNewWindow = '<leader>ow new-buf-window'

nmap <Leader>of <Action>(OpenProjectWindows)
let g:WhichKeyDesc_OpenLeader_OpenProjectWindows = '<leader>of find-window'

noremap <Leader>op <Action>(ActivateProjectToolWindow)
let g:WhichKeyDesc_OpenLeader_ActivateProjectToolWindow = '<leader>op toggle-project-view'

nmap <Leader>oo <Action>(RevealIn)
let g:WhichKeyDesc_OpenLeader_RevealIn = '<leader>oo reveal-in-finder'

nmap <Leader>ot <Action>(ActivateTerminalToolWindow)
let g:WhichKeyDesc_OpenLeader_ActivateTerminalToolWindow = '<leader>ot open-term'

nmap <Leader>o! <Action>(Terminal.OpenInTerminal)
let g:WhichKeyDesc_OpenLeader_Terminal_OpenInTerminal = '<leader>o! open-term-at-file-dir'


"
" +project

let g:WhichKeyDesc_ProjectLeader = '<leader>p +project'

map <Leader>pi <Action>(InvalidateCaches)
let g:WhichKeyDesc_ProjectLeader_InvalidateCaches = '<leader>pi invalidate-project-cache'

map <Leader>pp <Action>(ManageRecentProjects)
let g:WhichKeyDesc_ProjectLeader_ManageRecentProjects = '<leader>pp switch-projects'

map <Leader>pt <Action>(ActivateTODOToolWindow)
let g:WhichKeyDesc_ProjectLeader_ActivateTODOToolWindow = '<leader>pt show-todos'

" +run
let g:WhichKeyDesc_ProjectRunLeader = '<leader>pr +[r]un'

map <Leader>prw <Action>(ActivateRunToolWindow)
let g:WhichKeyDesc_ProjectRunLeader_ActivateRunToolWindow = '<leader>prw run-tool-window'

map <Leader>pra <Action>(RunAnything)
let g:WhichKeyDesc_ProjectRunLeader_RunAnything = '<leader>pra run-anything'

map <Leader>prr <Action>(Run)
let g:WhichKeyDesc_ProjectRunLeader_Run = '<leader>prr run-project'

map <Leader>prl <Action>(Rerun)
let g:WhichKeyDesc_ProjectRunLeader_Rerun = '<leader>prl rerun-latest-config'

map <Leader>prt <Action>(RerunTests)
let g:WhichKeyDesc_ProjectRunLeader_RerunTests = '<leader>prt rerun-tests'

map <Leader>prh <Action>(ChooseRunConfiguration)
let g:WhichKeyDesc_ProjectRunLeader_ChooseRunConfiguration = '<leader>prh recent-run-configs'

"
" +toggle

let g:WhichKeyDesc_ToggleLeader = '<leader>t +toggle'

map <Leader>tb <Action>(TogglePresentationMode)
let g:WhichKeyDesc_ToggleLeader_TogglePresentationMode = '<leader>tb presentation-mode'

map <Leader>tl <Action>(EditorToggleShowLineNumbers)
let g:WhichKeyDesc_ToggleLeader_EditorToggleShowLineNumbers = '<leader>tl line-numbers'

map <Leader>tr <Action>(ToggleReadOnlyAttribute)
let g:WhichKeyDesc_ToggleLeader_ToggleReadOnlyAttribute = '<leader>tr read-only-mode'

map <Leader>tw <Action>(EditorToggleUseSoftWraps)
let g:WhichKeyDesc_ToggleLeader_EditorToggleUseSoftWraps = '<leader>tw soft-wrapping'

map <Leader>tz <Action>(ToggleDistractionFreeMode)
let g:WhichKeyDesc_ToggleLeader_ToggleDistractionFreeMode = '<leader>tz distraction-free-mode'

map <Leader>tZ <Action>(ToggleZenMode)
let g:WhichKeyDesc_ToggleLeader_ToggleZenMode = '<leader>tZ zen-mode'

map <Leader>tF <Action>(ToggleFullScreen)
let g:WhichKeyDesc_ToggleLeader_ToggleFullScreen = '<leader>tF fullscreen'

map <Leader>tw <Action>(HideAllWindows)
let g:WhichKeyDesc_ToggleLeader_HideAllWindows = '<leader>tw tool-windows'
